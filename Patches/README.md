L2S-Hanabi Repair Results 
====

## Hanabi-results

Hanabi is evaluated based on 6 projects from 2 benchmarks (i.e. Defects4J and Bugs.jar).
The 6 projects are:



**All the 32 correctly fixed defects are:**

Project  | Defects |
--------- | --------|
Accumulo(1) | [ACCUMULO-151](#accumulo-151)
Camel(3) | [CAMEL-4474](#camel-4474), [CAMEL-7459](camel-7459), [CAMEL-8081](camel-8081)
Chart (3)| [C1](#chart-1), [C14](#chart-14), [C19](#chart-19) |
Lang (4)| [L2](#lang-2), [L7](#lang-7), [L24](#lang-24), [L35](#lang-35) |
Math (19)| [M3](#math-3), [M4](#math-4), [M5](#math-5), [M15](#math-15), [M22](#math-22), [M25](#math-25), [M26](#math-26), [M32](#math-32), [M33](#math-33), [M35](#math-35), [M48](#math-48), [M50](#math-50), [M53](#math-53), [M61](#math-61), [M63](#math-63), [M73](#math-73), [M85](#math-85), [M93](#math-93), [M94](#math-94) | 
Time (2)| [T15](#time-15), [T19](#time-19) |

There are 6 incorrect patches, all of which are all generated by Template 2. They are [CAMEL-7448](#camel-7448), [C13](#chart-13), [C17](#chart-17),  [M28](#math-28), [M81](#math-81), [M97](#math-97).

## Hanabi Correct Patches
Here we list all the 32 correct patches of Hanabi. For each defect, we show the employed template, the generated patch(es), and the developer's patch(es). Note that a defect may have mutiple buggy locations, so it may need more than one patch.

### ACCUMULO-151
The patch is identical to the developer's patch.

#### Hanabi patch (Template 2):
**File**: src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java

**Line**: 1797
```java
/*-- PATCH --*/      if ( combiners.contains(workKey) ) {
```
The patch is identical to the developer's patch.
#### The developer's patch:
**File**: src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java

**Line**: 1797
```java
-      if (combiners.isEmpty() || combiners.contains(workKey)) {
+      if (combiners.contains(workKey)) {
```

### CAMEL-4474
The condition is a contradictory that is always `false`, implementing the removement of the `if` statement.

#### Hanabi patch (Template 2):
**File**: src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java

**Line**: 59
```java
        // we assume its a file if the name has a dot in it (eg foo.txt)
        boolean isDirectory = file.isDirectory();
/*-- PATCH --*/        if ( file.isDirectory() && (!isDirectory && file.getName().contains(".")) ) {
            throw new IllegalArgumentException("Only directory is supported. Endpoint must be configured with a valid starting directory: " + file);
        }

```
#### The developer's patch:
**File**: camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java

**Line**: 49
```java
-        // we assume its a file if the name has a dot in it (eg foo.txt)
-        boolean isDirectory = file.isDirectory();
-        if (!isDirectory && file.getName().contains(".")) {
-            throw new IllegalArgumentException("Only directory is supported. Endpoint must be configured with a valid starting directory: " + file);
-        }
-
         // auto create starting directory if needed
-        if (!file.exists() && !isDirectory) {
+        if (!file.exists() && !file.isDirectory()) {
```

[\[BACK TO TOP\]](#Hanabi-results)

### CAMEL-7459

The patch of Hanabi is identical to the developer's patch.

#### Hanabi patch (Template 2):
**File**: camel-core/src/main/java/org/apache/camel/util/URISupport.java

**Line**: 158
```java
/*-- PATCH --*/                if ( i <= uri.length() - 2 ) {
```
The patch is identical to the developer's patch.
#### The developer's patch:
**File**: camel-core/src/main/java/org/apache/camel/util/URISupport.java

**Line**: 158
```java
-                if (i < uri.length() - 2) {
+                if (i <= uri.length() - 2) {

```

[\[BACK TO TOP\]](#Hanabi-results)

### CAMEL-8081

The variable `stoppedOnException` is always `false` within the loop, so the patch acts removing the `if` branch.

#### Hanabi patch (Template 2):
**File**: camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java

**Line**: 445
```java
/*-- PATCH --*/
                if ( stoppedOnException ) {
                    // we are timed out and no more tasks complete so break out
                    break;
```
The patch is identical to the developer's patch.
#### The developer's patch:
**File**: camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java

**Line**: 445
```java
-                if (future == null && timedOut) {
-                    // we are timed out and no more tasks complete so break out
-                    break;
-                } else if (future == null) {
+                if (future == null) {
                     // timeout occurred
                     AggregationStrategy strategy = getAggregationStrategy(null);
                     if (strategy instanceof TimeoutAwareAggregationStrategy) {

```

[\[BACK TO TOP\]](#Hanabi-results)

### Chart 1

The patch is identical to the developer's patch.

#### Hanabi patch (Template 2):
**File**: source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java

**Line**: 1797
```java
/*-- PATCH --*/        if (dataset == null) {
```
The patch is identical to the developer's patch.
#### The developer's patch:
**File**: source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java

**Line**: 1797
```java
+        if (dataset == null) {
-        if (dataset != null) {
```

[\[BACK TO TOP\]](#Hanabi-results)

### Chart 14

The patches are identical to the developer's patches.

#### Hanabi patch 1 (Template 1):
**File**: source/org/jfree/chart/plot/CategoryPlot.java

**Line**: 2163
```java
            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                    index));
        }
/*-- PATCH --*/if(markers == null){return false;}        boolean removed = markers.remove(marker);
```

#### The developer's patch 1:
**File**: source/org/jfree/chart/plot/CategoryPlot.java

**Line**: 2163
``` java
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
+        if (markers == null) {
+            return false;
+        }
         boolean removed = markers.remove(marker);
```

#### Hanabi patch 2 (Template 1):
**File**: source/org/jfree/chart/plot/CategoryPlot.java

**Line**: 2448
```java
            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                    index));
        }
/*-- PATCH --*/if(markers == null){return false;}        boolean removed = markers.remove(marker);
```

#### The developer's patch 2:
**File**: source/org/jfree/chart/plot/CategoryPlot.java

**Line**: 2448

``` java
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
+        if (markers == null) {
+            return false;
+        }
         boolean removed = markers.remove(marker);
```

#### Hanabi patch 3 (Template 1):
**File**: source/org/jfree/chart/plot/XYPlot.java

**Line**: 2290

```java
            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                    index));
        }
/*-- PATCH --*/if(markers == null){return false;}        boolean removed = markers.remove(marker);
```

#### The developer's patch 3:
**File**: source/org/jfree/chart/plot/XYPlot.java

**Line**: 2290

``` java
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
+        if (markers == null) {
+            return false;
+        }
         boolean removed = markers.remove(marker);
```

#### Hanabi patch 4 (Template 1):
**File**: source/org/jfree/chart/plot/XYPlot.java

**Line**: 2529

```java
            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                    index));
        }
/*-- PATCH --*/if(markers == null){return false;}        boolean removed = markers.remove(marker);
```

#### The developer's patch 4:
**File**: source/org/jfree/chart/plot/XYPlot.java

**Line**: 2529

``` java
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
+        if (markers == null) {
+            return false;
+        }
         boolean removed = markers.remove(marker);
```

[\[BACK TO TOP\]](#Hanabi-results)


### Chart 19
The patches are identical to the developer's patches.

#### Hanabi patch 1 (Template 1):
**File**: source/org/jfree/chart/plot/CategoryPlot.java

**Line**: 695

```java
     * @since 1.0.3
     */
    public int getDomainAxisIndex(CategoryAxis axis) {
/*-- PATCH --*/if(axis == null){throw new IllegalArgumentException();}        return this.domainAxes.indexOf(axis);
    }
```

#### The developer's patch 1:
**File**: source/org/jfree/chart/plot/CategoryPlot.java

**Line**: 695

``` java
      * @since 1.0.3
      */
     public int getDomainAxisIndex(CategoryAxis axis) {
+        if (axis == null) {
+            throw new IllegalArgumentException("Null 'axis' argument.");
+        }
         return this.domainAxes.indexOf(axis);
     }
```

#### Hanabi patch 2 (Template 1):
**File**: source/org/jfree/chart/plot/CategoryPlot.java

**Line**: 973
```java
     * @since 1.0.7
     */
    public int getRangeAxisIndex(ValueAxis axis) {
/*-- PATCH --*/if(axis == null){throw new IllegalArgumentException();}        int result = this.rangeAxes.indexOf(axis);
```

#### The developer's patch 2:
**File**: source/org/jfree/chart/plot/CategoryPlot.java

**Line**: 973

``` java
      * @since 1.0.7
      */
     public int getRangeAxisIndex(ValueAxis axis) {
+        if (axis == null) {
+            throw new IllegalArgumentException("Null 'axis' argument.");
+        }
        int result = this.rangeAxes.indexOf(axis);
```

[\[BACK TO TOP\]](#Hanabi-results)

### Lang 2
The API `indexOf` returns `-1` if the string does not contains the parameter, so the patch of Hanabi is sementically identical to the developer's patch.


#### Hanabi patch (Template 1):
**File**: src/main/java/org/apache/commons/lang3/LocaleUtils.java

**Line**: 89

``` java
        if (str == null) {
            return null;
        }
/*-- PATCH --*/if(str.indexOf("#") >= 0){throw new IllegalArgumentException();}        final int len = str.length();
```


#### The developer's patch:
**File**: src/main/java/org/apache/commons/lang3/LocaleUtils.java

**Line**: 89

``` java
         if (str == null) {
             return null;
         }
+        if (str.contains("#")) { // LANG-879 - Cannot handle Java 7 script & extensions
+            throw new IllegalArgumentException("Invalid locale format: " + str);
+        }
        final int len = str.length();
```

[\[BACK TO TOP\]](#Hanabi-results)


### Lang 7
The `trim()` is redundant in the developer's patch, so the patch of Hanabi is identical to the developer's patch.

#### Hanabi patch (Template 3):
**File**: src/main/java/org/apache/commons/lang3/math/NumberUtils.java

**Line**: 453

**Analysis**: The method `createNumber` at line 445 will be finally invoked in the execution flow, and fix at this point is equal to the developer's patch.

```java
    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException("A blank string is not a valid number");
        }  
        if (str.startsWith("--")) {
/*-- PATCH --*/throw new NumberFormatException();
        }
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/lang3/math/NumberUtils.java

**Line**: 449, 715
``` java
@@ -449,6 +449,9 @@ public class NumberUtils {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException("A blank string is not a valid number");
         }  
-        if (str.startsWith("--")) {
-            return null;
-        }
         if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) {
             int hexDigits = str.length() - 2; // drop 0x
             if (str.startsWith("-")) { // drop -
@@ -715,13 +718,10 @@ public class NumberUtils {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException("A blank string is not a valid number");
         }
+        if (str.trim().startsWith("--")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
             // to be in specification of class. OS X Java parses it to 
             // a wrong value.
+            throw new NumberFormatException(str + " is not a valid number.");
+        }
         return new BigDecimal(str);
     }
```

[\[BACK TO TOP\]](#Hanabi-results)

### Lang 24
The patch is semantically equal to the developer's patch. Their truth table are idential.

#### Hanabi patch (Template 1):
**File**: src/main/java/org/apache/commons/lang3/math/NumberUtils.java

**Line**: 1410

```java
            if (chars[i] == 'l'
                || chars[i] == 'L') {
/*-- PATCH --*/if(hasDecPoint){return false;}                // not allowing L with an exponent or decimal point
                return foundDigit && !hasExp;
            }
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/lang3/math/NumberUtils.java

**Line**: 1410

```java
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                 // not allowing L with an exponent or decimal point
+                return foundDigit && !hasExp && !hasDecPoint;
-                return foundDigit && !hasExp;
             }
             // last character is illegal
             return false;
```

[\[BACK TO TOP\]](#Hanabi-results)

### Lang 35

The patches are semantically equal to the developer's patches, because the predicate `element == null` must be `true` in the last `else` branches.

#### Hanabi patch 1 (Template 1):
**File**: src/main/java/org/apache/commons/lang3/ArrayUtils.java

**Line**: 3292

**Analysis**: The Hanabi patch and the developer's pather are sementically equal, because in the patches branch `element == null` must be true.

```java
    public static <T> T[] add(T[] array, T element) {
        Class<?> type;
        if (array != null){
            type = array.getClass();
        } else if (element != null) {
            type = element.getClass();
        } else {
/*-- PATCH --*/if(element == null){throw new IllegalArgumentException();}            type = Object.class;
        }
        @SuppressWarnings("unchecked") // type must be T
        T[] newArray = (T[]) copyArrayGrow1(array, type);
        newArray[newArray.length - 1] = element;
        return newArray;
    }

```

#### The developer's patch 1:
**File**: src/main/java/org/apache/commons/lang3/ArrayUtils.java

**Line**: 3292

```java
    public static <T> T[] add(T[] array, T element) {
        Class<?> type;
        if (array != null){
            type = array.getClass();
        } else if (element != null) {
            type = element.getClass();
        } else {
+            throw new IllegalArgumentException("Arguments cannot both be null");            
-            type = Object.class;
        }
        @SuppressWarnings("unchecked") // type must be T
        T[] newArray = (T[]) copyArrayGrow1(array, type);
        newArray[newArray.length - 1] = element;
        return newArray;
    }
```

#### Hanabi patch 2 (Template 1):
**File**: src/main/java/org/apache/commons/lang3/ArrayUtils.java

**Line**: 3571

**Analysis**: The Hanabi patch and the developer's pather are sementically equal, because in the patches branch `element == null` must be true.

```java
    public static <T> T[] add(T[] array, int index, T element) {
        Class<?> clss = null;
        if (array != null) {
            clss = array.getClass().getComponentType();
        } else if (element != null) {
            clss = element.getClass();
        } else {
/*-- PATCH --*/if(element == null){throw new IllegalArgumentException();}            return (T[]) new Object[] { null };
        }
        @SuppressWarnings("unchecked") // the add method creates an array of type clss, which is type T
        final T[] newArray = (T[]) add(array, index, element, clss);
        return newArray;
    }
```

#### The developer's patch 2:
**File**: src/main/java/org/apache/commons/lang3/ArrayUtils.java

**Line**: 3571

```java
    public static <T> T[] add(T[] array, int index, T element) {
        Class<?> clss = null;
        if (array != null) {
            clss = array.getClass().getComponentType();
        } else if (element != null) {
            clss = element.getClass();
        } else {
+            throw new IllegalArgumentException("Array and element cannot both be null");            
-            return (T[]) new Object[] { null };
        }
        @SuppressWarnings("unchecked") // the add method creates an array of type clss, which is type T
        final T[] newArray = (T[]) add(array, index, element, clss);
        return newArray;
    }
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 3
The patch is identical to the developer's patch. The fix location is within a legal range and does not trigger other exceptions.

#### Hanabi patch (Template 1):
**File**: src/main/java/org/apache/commons/math3/util/MathArrays.java

**Line**: 818
```java
        if (len != b.length) {
            throw new DimensionMismatchException(len, b.length);
        }

            // Revert to scalar multiplication.
/*-- PATCH --*/if(len == 1){return a[0] * b[0];}
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math3/util/MathArrays.java

**Line**: 818

```java
        if (len != b.length) {
            throw new DimensionMismatchException(len, b.length);
        }

+       if (len == 1) {
            // Revert to scalar multiplication.
+           return a[0] * b[0];
+       }

        final double[] prodHigh = new double[len];
```

[\[BACK TO TOP\]](#Hanabi-results)

### Math 4

The patches are identical to the developer's patch.

#### Hanabi patch 1 (Template 1):
**File**: src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java

**Line**: 111

```java
        // compute the intersection on infinite line
        Vector3D v1D = line.intersection(subLine.line);
/*-- PATCH --*/if(v1D == null){return null;}
        // check location of point with respect to first sub-line
        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
```

#### The developer's patch 1:
**File**: src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java

**Line**: 111

```java
 
         // compute the intersection on infinite line
         Vector3D v1D = line.intersection(subLine.line);
+        if (v1D == null) {
+            return null;
+        }
 
         // check location of point with respect to first sub-line
         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
```

#### Hanabi patch 2 (Template 1):
**File**: src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java

**Line**: 115

```java

        // compute the intersection on infinite line
        Vector2D v2D = line1.intersection(line2);
/*-- PATCH  --*/if(v2D == null){return null;}
        // check location of point with respect to first sub-line
        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
```

#### The developer's patch 2:
**File**: src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java

**Line**: 115
```java
 
         // compute the intersection on infinite line
         Vector2D v2D = line1.intersection(line2);
+        if (v2D == null) {
+            return null;
+        }
 
         // check location of point with respect to first sub-line
         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 5

The patch is identical to the developer's patch.

#### Hanabi patch (Template 3):
**File**: src/main/java/org/apache/commons/math3/complex/Complex.java

**Line**: 302

```java
        }

        if (real == 0.0 && imaginary == 0.0) {
/*-- PATCH --*/return INF;
        }
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math3/complex/Complex.java

**Line**: 302

```java
         }
 
         if (real == 0.0 && imaginary == 0.0) {
+            return INF;
-            return NaN;
         }
```

[\[BACK TO TOP\]](#Hanabi-results)

### Math 15

The developer's patch shrinks the range handled by the `if-then` branch, while Hanabi's patch handle all the cases by directly return the oracle, i.e. the JDK version of calculating `pow`.
Moreover, duing to the float number format, the variable `y` must be even, so the value of `pow(x,y)` equals to the value of `pow(-x, y)`.
So the patch is semantically equal to the developer's patch.

#### Hanabi patch (Template 3):
**File**: src/main/java/org/apache/commons/math3/complex/Complex.java

**Line**: 302


**Analysis**: Compared with human's patch, the condition range of Hanabi is wider (\[-TWO_POWER_52, TWO_POWER_52\] > \[-TWO_POWER_53, TWO_POWER_53\]), and returning the oracle. 

```java
        /* Handle special case x<0 */
        if (x < 0) {
            // y is an even integer in this case
            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
/*-- PATCH --*/return Math.pow(x,y);
            }

```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math3/util/FastMath.java

**Line**: 1539

```java
         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
+            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {
-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
                 return pow(-x, y);
             }
 
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 22

The Hanabi patches are identical to developer's patches.

#### Hanabi patch 1 (Template 3):
**File**: src/main/java/org/apache/commons/math3/distribution/FDistribution.java

**Line**: 272

```java
     /** {@inheritDoc} */
     public boolean isSupportLowerBoundInclusive() {
/*-- PATCH --*/return false;
     }
```

#### The developer's patch 1:
**File**: src/main/java/org/apache/commons/math3/distribution/FDistribution.java

**Line**: 272

```java
     /** {@inheritDoc} */
     public boolean isSupportLowerBoundInclusive() {
+        return false;
-        return true;
     }
```

#### Hanabi patch 2 (Template 3):
**File**: src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java

**Line**: 181

```java
     /** {@inheritDoc} */
     public boolean isSupportUpperBoundInclusive() {
/*-- PATCH --*/return true;
     }
```

#### The developer's patch 2:
**File**: src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java

**Line**: 181
```java
     /** {@inheritDoc} */
     public boolean isSupportUpperBoundInclusive() {
+        return true;
-        return false;
     }
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 25

The patch of Hanabi is identical to the developer's patch.

#### Hanabi patch (Template 1):
**File**: src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java

**Line**: 320

```java
                 }
                a = 0.5 * (yMax - yMin);
            } else {
                    // In some ill-conditioned cases (cf. MATH-844), the guesser
                    // procedure cannot produce sensible results.
/*-- PATCH --*/if(c2 == 0){throw new MathIllegalStateException();}
                a = FastMath.sqrt(c1 / c2);
                omega = FastMath.sqrt(c2 / c3);
            }
        }
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java

**Line**: 320

```java
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
+                if (c2 == 0) {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
+                }
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3); 
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 26

The variable `overflow` is a positive number, so `overflow` equals to its abstract value, which can be calculated by `FastMath.abs()` or `Math.abs()`.
Thus the Hanabi patches are semantically equal to the developer's patches.

#### Hanabi patch 1 (Template 2):
**File**: src/main/java/org/apache/commons/math3/fraction/Fraction.java

**Line**: 178

**Analysis**: The variable `overflow` is unmodified, thus `FastMath.abs(overflow)` equals to `overflow`.
```java
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
/*-- PATCH --*/        if ( FastMath.abs(a0) > FastMath.abs(overflow) ) {
            throw new FractionConversionException(value, a0, 1l);
        }
```

#### The developer's patch 1:
**File**: src/main/java/org/apache/commons/math3/fraction/Fraction.java

**Line**: 178

```java
         long overflow = Integer.MAX_VALUE;
         double r0 = value;
         long a0 = (long)FastMath.floor(r0);
+        if (FastMath.abs(a0) > overflow) {
-        if (a0 > overflow) {
             throw new FractionConversionException(value, a0, 1l);
         }
```

#### Hanabi patch 2 (Template 2):
**File**: src/main/java/org/apache/commons/math3/fraction/Fraction.java

**Line**: 206

**Analysis**: The method `FastMath.abs()` equals to `Math.abs()`, so the patch is correct.
```java
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
/*-- PATCH --*/            if ( Math.abs(p2) > overflow || Math.abs(q2) > overflow ) {
                throw new FractionConversionException(value, p2, q2);
            }
```

#### The developer's patch 2:
**File**: src/main/java/org/apache/commons/math3/fraction/Fraction.java

**Line**: 206
```java
             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
-            if ((p2 > overflow) || (q2 > overflow)) {
                 throw new FractionConversionException(value, p2, q2);
             }
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 32

The patch is identical to the developer's patch.

#### Hanabi patch (Template 2):
**File**: src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java

**Line**: 320

```java
        if (v.length == 0) {
            final BSPTree<Euclidean2D> tree = getTree(false);
/*-- PATCH --*/            if ( tree.getCut() == null && ((Boolean)tree.getAttribute()) ) {
                // the instance covers the whole space
                setSize(Double.POSITIVE_INFINITY);
                setBarycenter(Vector2D.NaN);
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java

**Line**: 133

```java
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
-            if ((Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
```

[\[BACK TO TOP\]](#Hanabi-results)

### Math 33

The patch is identical to the developer's patch.

#### Hanabi patch (Template 2):
**File**: src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java

**Line**: 335

```java
        // positive cost non-artificial variables
        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
            final double entry = tableau.getEntry(0, i);
/*-- PATCH --*/            if ( Precision.compareTo(entry,0d,epsilon) > 0 ) {
                columnsToDrop.add(i);
            }
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java

**Line**: 335

```java
         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {
-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 35

The patches just lift the check to another place, which are semantically identical to the developer's patches.

#### Hanabi patch 1 (Template 1):
**File**: src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java

**Line**: 48

**Analysis**: In the super constructor, `populationLimit` can not be less than 0, thus `populationLimit < 0` is always false. So the Hanabi patch equals to `elitismRate < 0 || elitismRate > 1`.

```java
		super(chromosomes, populationLimit);
        this.elitismRate = elitismRate;
/*-- PATCH --*/if(populationLimit < 0 || elitismRate > 1){throw new OutOfRangeException(null,null,null);}
/*-- PATCH --*/if(elitismRate < 0){throw new OutOfRangeException(null,null,null);}    
		}
```

#### The developer's patch 1:
**File**: src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java

**Line**: 48

```java
         super(chromosomes, populationLimit);
+        setElitismRate(elitismRate);
-        this.elitismRate = elitismRate;
     }
	//...
    public void setElitismRate(final double elitismRate) {
        if (elitismRate < 0 || elitismRate > 1) {
            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);
        }
        this.elitismRate = elitismRate;
    }
```

#### Hanabi patch 2 (Template 1):
**File**: src/main/java/org/apache/commons/math3/fraction/Fraction.java

**Line**: 62

**Analysis**: Same as the 1st patch.
```java
        super(populationLimit);
        this.elitismRate = elitismRate;
/*-- PATCH --*/if(elitismRate < 0){throw new OutOfRangeException(null,null,null);}
/*-- PATCH --*/if(populationLimit < 0 || elitismRate > 1){throw new OutOfRangeException(null,null,null);}    
		}
```

#### The developer's patch 2:
**File**: src/main/java/org/apache/commons/math3/fraction/Fraction.java

**Line**: 62
```java
     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
         super(populationLimit);
+        setElitismRate(elitismRate);
-        this.elitismRate = elitismRate;
     }
	//...
	public void setElitismRate(final double elitismRate) {
        if (elitismRate < 0 || elitismRate > 1) {
            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);
        }
        this.elitismRate = elitismRate;
    }
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 48

The Hanabi's patch is identical to the developer's patch.

#### Hanabi patch (Template 1):
**File**: src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java

**Line**: 186

**Analysis**: For the two variable `x1` and `x` are `double`, comparing the double with a precision range is better. So the Hanabi patch is better than the developer's.

```java
                case REGULA_FALSI:
                    // Detect early that algorithm is stuck, instead of waiting
/*-- PATCH --*/if(x == x1){throw new ConvergenceException();}                    // for the maximum number of iterations to be exceeded.
                    break;
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java

**Line**: 186

```java
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
+                    if (x == x1) {
+                        throw new ConvergenceException();
+                    }
                     break;
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 50

The variable `x` could never be greater than `x1`, so the condition is constantly `false`.

#### Hanabi patch (Template 2):
**File**: src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java

**Line**: 184

**Analysis**: The variable `x` is always less than `x1`, so the condition `x > x1` is contantly false. At last the patch skips the if statement, same as the developer's patch.

```java
                 case REGULA_FALSI:
                    // Nothing.
/*-- PATCH  --*/                    if ( FastMath.abs(x) > x1 ) {
                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java

**Line**: 184

```java
                 case REGULA_FALSI:
                     // Nothing.
-                    if (x == x1) {
-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
-                        f0 = computeObjectiveValue(x0);
-                    }
                     break;
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 53

The Hanabi patch is semantically equal to the developer's patch.

#### Hanabi patch (Template 1):
**File**: src/main/java/org/apache/commons/math/complex/Complex.java

**Line**: 150

```java
    public Complex add(Complex rhs)
        throws NullArgumentException {
/*-- PATCH --*/if(isNaN() || rhs.isNaN()){return NaN;}        MathUtils.checkNotNull(rhs);
        return createComplex(real + rhs.getReal(),
            imaginary + rhs.getImaginary());
    }
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math/complex/Complex.java

**Line**: 150

```java
     public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
+        if (isNaN || rhs.isNaN) {
+            return NaN;
+        }
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 61

The Hanabi patch is identical to the developer's patch.


#### Hanabi patch (Template 3):
**File**: src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java

**Line**: 91

```java
    public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
        if (p <= 0) {
/*-- PATCH --*/throw new org.apache.commons.math.exception.NotStrictlyPositiveException(null);
        }
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java

**Line**: 91

```java
     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
         if (p <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);
-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
         }
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 63

The Hanabi patch is semantically equal to the developer's patch.

#### Hanabi patch (Template 1):
**File**: src/main/java/org/apache/commons/math/util/MathUtils.java

**Line**: 414

**Analysis**: In the Hanabi patch, either `x` or `y` is NaN, the method should return false, which is same as the developer's patch. 

```java
     */
    public static boolean equals(double x, double y) {
/*-- PATCH --*/if(Double.isNaN(x)){return false;}        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
    }
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math/util/MathUtils.java

**Line**: 414

```java
      */
     public static boolean equals(double x, double y) {
+        return equals(x, y, 1);
-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
     }
```

[\[BACK TO TOP\]](#Hanabi-results)

### Math 73

The Hanabi patch is identical to the developer's patch.

#### Hanabi patch (Template 1):
**File**: src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java

**Line**: 133


```java
            return solve(f, initial, yInitial, max, yMax, initial, yInitial);
        }


/*-- PATCH --*/if(yMin * yMax > 0){throw new IllegalArgumentException();}        // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);
```

#### The developer's patch:
**File**: src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java

**Line**: 133

```java
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
+        if (yMin * yMax > 0) {
+            throw MathRuntimeException.createIllegalArgumentException(
+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
+        }
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 85

The Hanabi patch is identical to the developer's patch.

#### Hanabi patch (Template 2):
**File**: src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java

**Line**: 195


```java
            numIterations++ ;
        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                ((a > lowerBound) || (b < upperBound)));
  
/*-- PATCH --*/        if ( fa * fb > 0  ) {
             throw new ConvergenceException(
                       "number of iterations={0}, maximum iterations={1}, " +
                       "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +
```

#### The developer's patch:
**File**: src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java

**Line**: 195

```java
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
+        if (fa * fb > 0.0 ) {
-        if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       "number of iterations={0}, maximum iterations={1}, " +
                       "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " +
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 93

The Hanabi patch is semantically equal to the developer's patch.

#### Hanabi patch (Template 1):
**File**: src/java/org/apache/commons/math/util/MathUtils.java

**Line**: 373

**Analysis**: The reuslt of `factorial(20)` and `factorial(21)` in the Hanabi patch is same as the developer's.

```java
    public static double factorialDouble(final int n) {
        if (n < 0) {
            throw new IllegalArgumentException("must have n >= 0 for n!");
        }
/*-- PATCH --*/if(n < 20){return patch_method(n);}        return Math.floor(Math.exp(factorialLog(n)) + 0.5);
    }
```

#### The developer's patch:
**File**: src/java/org/apache/commons/math/util/MathUtils.java

**Line**: 342, 376, 399

```java
@@ -342,10 +342,8 @@ public final class MathUtils {
      * @throws IllegalArgumentException if n < 0
      */
     public static long factorial(final int n) {
+        if (n < 0) {
+            throw new IllegalArgumentException("must have n >= 0 for n!");
+        }
+        if (n > 20) {
-        long result = Math.round(factorialDouble(n));
-        if (result == Long.MAX_VALUE) {
             throw new ArithmeticException(
                     "factorial value is too large to fit in a long");
         }
@@ -376,9 +374,6 @@ public final class MathUtils {
         if (n < 0) {
             throw new IllegalArgumentException("must have n >= 0 for n!");
         }
+        if (n < 21) {
+            return factorial(n);
+        }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }
 
@@ -399,9 +394,6 @@ public final class MathUtils {
         if (n < 0) {
             throw new IllegalArgumentException("must have n > 0 for n!");
         }
+        if (n < 21) {
+            return Math.log(factorial(n));
+        }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
```

[\[BACK TO TOP\]](#Hanabi-results)


### Math 94

The Hanabi patch is identical to the developer's patch.

#### Hanabi patch (Template 2):
**File**: src/java/org/apache/commons/math/util/MathUtils.java

**Line**: 411


```java
    public static int gcd(int u, int v) {
/*-- PATCH --*/        if ( u == 0 || v == 0 ) {
            return (Math.abs(u) + Math.abs(v));
        }
```

#### The developer's patch:
**File**: src/java/org/apache/commons/math/util/MathUtils.java

**Line**: 411

```java
     public static int gcd(int u, int v) {
+        if ((u == 0) || (v == 0)) {
-        if (u * v == 0) {
             return (Math.abs(u) + Math.abs(v));
         }
```

[\[BACK TO TOP\]](#Hanabi-results)



### Time 15

The Hanabi patch is identical to the developer's patch.

#### Hanabi patch (Template 1):
**File**: src/main/java/org/joda/time/field/FieldUtils.java

**Line**: 136


```java
        switch (val2) {
            case -1:
/*-- PATCH --*/if(val1 == Long.MIN_VALUE){throw new ArithmeticException();}                return -val1;
            case 0:
```

#### The developer's patch:
**File**: src/main/java/org/joda/time/field/FieldUtils.java

**Line**: 136

```java
         switch (val2) {
             case -1:
+                if (val1 == Long.MIN_VALUE) {
+                    throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2);
+                }
                 return -val1;
```

[\[BACK TO TOP\]](#Hanabi-results)


### Time 19

The Hanabi patch is semantically equal to the developer's patch.

#### Hanabi patch (Template 2):
**File**: src/main/java/org/joda/time/DateTimeZone.java

**Line**: 897

**Analysis**: The variable `offsetLocal` is an `int`, so `offsetLocal > -1` semantically equals to `offsetLocal >= 0`.

```java
/*-- PATCH --*/        } else if ( offsetLocal > -1 ) {
```

#### The developer's patch:
**File**: src/main/java/org/joda/time/DateTimeZone.java

**Line**: 897

```java
+        } else if (offsetLocal >= 0) {
-        } else if (offsetLocal > 0) {
```

[\[BACK TO TOP\]](#Hanabi-results)










